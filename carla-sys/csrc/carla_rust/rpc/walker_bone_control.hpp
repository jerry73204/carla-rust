#pragma once

#include <memory>
#include <vector>
#include <string>
#include "carla/Memory.h"
#include "carla/geom/Transform.h"
#include "carla/rpc/Transform.h"
#include "carla/rpc/WalkerBoneControlIn.h"
#include "carla/rpc/WalkerBoneControlOut.h"

namespace carla_rust {
namespace rpc {

using carla::geom::Transform;
using carla::rpc::BoneTransformDataIn;
using carla::rpc::BoneTransformDataOut;
using carla::rpc::WalkerBoneControlIn;
using carla::rpc::WalkerBoneControlOut;
using carla_rust::geom::FfiTransform;

// Wrapper for BoneTransformDataIn with field access
// BoneTransformDataIn is std::pair<std::string, geom::Transform>
struct FfiBoneTransformDataIn {
    std::string bone_name;
    Transform transform;

    BoneTransformDataIn ToCpp() const {
        // Create the pair: first=bone_name, second=transform
        return std::make_pair(bone_name, transform);
    }
};

// Wrapper for BoneTransformDataOut with field access
// Methods on this class CAN be generated by autocxx
class FfiBoneTransformDataOut {
public:
    FfiBoneTransformDataOut() = default;

    static FfiBoneTransformDataOut FromCpp(const BoneTransformDataOut& cpp) {
        FfiBoneTransformDataOut result;
        result.bone_name_ = cpp.bone_name;
        result.world_ = cpp.world;
        result.component_ = cpp.component;
        result.relative_ = cpp.relative;
        return result;
    }

    // Getters for Rust access - return values directly
    std::unique_ptr<std::string> bone_name() { return std::make_unique<std::string>(bone_name_); }
    FfiTransform world() { return *reinterpret_cast<const FfiTransform*>(&world_); }
    FfiTransform component() { return *reinterpret_cast<const FfiTransform*>(&component_); }
    FfiTransform relative_transform() { return *reinterpret_cast<const FfiTransform*>(&relative_); }

private:
    std::string bone_name_;
    Transform world_;
    Transform component_;
    Transform relative_;
};

// Wrapper for WalkerBoneControlIn with vector conversion
class FfiWalkerBoneControlIn {
public:
    FfiWalkerBoneControlIn() = default;

    void AddBone(const FfiBoneTransformDataIn& bone) { bones_.push_back(bone); }

    // Helper to add bone with string and transform directly - this method CAN be generated by
    // autocxx
    void AddBoneWithTransform(const std::string& name, const Transform& transform) {
        FfiBoneTransformDataIn bone;
        bone.bone_name = name;
        bone.transform = transform;
        bones_.push_back(bone);
    }

    WalkerBoneControlIn ToCpp() const {
        WalkerBoneControlIn result;
        for (const auto& bone : bones_) {
            result.bone_transforms.push_back(bone.ToCpp());
        }
        return result;
    }

private:
    std::vector<FfiBoneTransformDataIn> bones_;
};

// Wrapper for WalkerBoneControlOut with vector access
// Methods on this class CAN be generated by autocxx
class FfiWalkerBoneControlOut {
public:
    FfiWalkerBoneControlOut() = default;

    static FfiWalkerBoneControlOut FromCpp(const WalkerBoneControlOut& cpp) {
        FfiWalkerBoneControlOut result;
        for (const auto& bone : cpp.bone_transforms) {
            result.bones_.push_back(FfiBoneTransformDataOut::FromCpp(bone));
        }
        return result;
    }

    // Accessor methods
    size_t bone_count() { return bones_.size(); }

    // Return unique_ptr to avoid returning Opaque type by value or reference
    std::unique_ptr<FfiBoneTransformDataOut> bone_at(size_t index) {
        if (index >= bones_.size()) {
            throw std::out_of_range("Bone index out of range");
        }
        return std::make_unique<FfiBoneTransformDataOut>(bones_[index]);
    }

private:
    std::vector<FfiBoneTransformDataOut> bones_;
};

// Free functions for accessing Opaque types - autocxx CAN generate these
inline std::unique_ptr<std::string> FfiBoneTransformDataOut_bone_name(
    FfiBoneTransformDataOut& bone) {
    return bone.bone_name();
}

inline FfiTransform FfiBoneTransformDataOut_world(FfiBoneTransformDataOut& bone) {
    return bone.world();
}

inline FfiTransform FfiBoneTransformDataOut_component(FfiBoneTransformDataOut& bone) {
    return bone.component();
}

inline FfiTransform FfiBoneTransformDataOut_relative_transform(FfiBoneTransformDataOut& bone) {
    return bone.relative_transform();
}

inline size_t FfiWalkerBoneControlOut_bone_count(FfiWalkerBoneControlOut& control) {
    return control.bone_count();
}

inline std::unique_ptr<FfiBoneTransformDataOut> FfiWalkerBoneControlOut_bone_at(
    FfiWalkerBoneControlOut& control, size_t index) {
    return control.bone_at(index);
}

inline void FfiWalkerBoneControlIn_add_bone(FfiWalkerBoneControlIn& control,
                                            const std::string& name,
                                            const FfiTransform& transform) {
    // Convert FfiTransform back to carla::geom::Transform for C++ API
    const auto& cpp_transform = *reinterpret_cast<const carla::geom::Transform*>(&transform);
    control.AddBoneWithTransform(name, cpp_transform);
}

}  // namespace rpc
}  // namespace carla_rust
